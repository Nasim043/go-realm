# গোল্যাঙ্গে রিসিভার ফাংশন

## রিসিভার ফাংশন কি?

Go (Golang)-এ Receiver Function হলো এমন একটি ফাংশন, যা কোনো নির্দিষ্ট type (সাধারণত struct)–এর সাথে যুক্ত থাকে। সহজ ভাষায় বললে, এটি Go-তে কোনো struct বা user-defined type-এর উপর method তৈরি করার উপায়।

```go
type User struct {
    Name string
    Age  int
}

// Receiver function
func (u User) Greet() string {
    return fmt.Sprintf("Hello, %s!", u.Name)
}
```

#### Basic Syntax

```go
func (receiverName ReceiverType) MethodName(parameters) returnTypes {
    // Method body
}
```

### Value vs Pointer Receivers

| Feature           | Value Receiver (`u User`) | Pointer Receiver (`u *User`) |
| ----------------- | ------------------------- | ---------------------------- |
| অরিজিনাল ডাটা পরিবর্তন | ❌ না                     | ✅ হ্যাঁ                       |
| মেমোরি ব্যবহার      | সম্পূর্ণ ভ্যালুর কপি তৈরি করে       | শুধু রেফারেন্স ব্যবহার করে (৪/৮ বাইট)   |
| কোন কাজে উপযুক্ত        | শুধুমাত্র ডাটা পড়ার কাজ (Read-only)      | ডাটা পরিবর্তনের কাজ (Mutating)          |
| Nil (নাল) সেফটি        | সবসময় নিরাপদ               | Nil হলে panic হতে পারে             |

```go
// Value receiver (read-only)
func (u User) GetAge() int {
    return u.Age
}

// Pointer receiver (can modify)
func (u *User) Birthday() {
    u.Age++
}
```

## FAQ: সাধারণ ইন্টারভিউ প্রশ্ন

### 1. কখন Pointer Receiver ব্যবহার করা উচিত?

**A:** Pointer receiver ব্যবহার করা হয় যখন—

- রিসিভারের ভ্যালু পরিবর্তন (modify) করার প্রয়োজন হয়

- বড় struct নিয়ে কাজ করতে হয় (অপ্রয়োজনীয় কপি এড়ানোর জন্য)

- এমন interface method ইমপ্লিমেন্ট করতে হয় যেখানে ডাটা পরিবর্তন দরকার

### 2. যেকোনো type-এর method কি থাকতে পারে?

**A:** হ্যাঁ, পারে — তবে কিছু সীমাবদ্ধতা আছেঃ

```go
type MyInt int

func (m MyInt) Double() int {
    return int(m * 2)
}
```

**Exception:** কিছু সীমাবদ্ধতা আছেঃ

- Built-in types সরাসরি ব্যবহার করা যায় না (alias করতে হবে)
- Pointers সরাসরি ব্যবহার করা যায় না
- Interfaces-এ ব্যবহার করা যায় না

### 3. Receiver name-এর কনভেনশন কী?

**A:** সাধারণত টাইপের সাথে মিল রেখে ১-২ অক্ষর ব্যবহার করা হয়:

- `User`-এর জন্য `u`
- `Product`-এর জন্য `p`
- `Client`-এর জন্য `c`

### 4. Interfaces-এ কি receiver method থাকতে পারে?

**A:** না, interfaces শুধুমাত্র method signatures ডিফাইন করে কিন্তু সেগুলো implement করতে পারে না।

### 5. Built-in types-এর method থাকতে পারে কি?

**A:** শুধুমাত্র type aliasing-এর মাধ্যমে সম্ভব:

```go
type Celsius float64

func (c Celsius) ToFahrenheit() float64 {
    return float64(c)*9/5 + 32
}
```

### 6. Zero-value receiver-এর আচরণ কেমন?

**A:** Nil receivers-এও method কল করা যায় যদি সঠিকভাবে হ্যান্ডল করা হয়:

```go
func (a *Account) Balance() float64 {
    if a == nil {
        return 0.0
    }
    return a.balance
}
```

### 7. Go কীভাবে value এবং pointer-এ method call হ্যান্ডল করে?

**A:** Go স্বয়ংক্রিয়ভাবে কনভার্ট করে:

- `value.Method()` উভয় value এবং pointer receiver-এর জন্য কাজ করে
- `pointer.Method()` উভয় receiver type-এর জন্য কাজ করে

### প্র্যাক্টিক্যাল প্যাটার্নসমূহ

#### মেথড চেইনিং

```go
type Calculator struct { Value float64 }

func (c *Calculator) Add(x float64) *Calculator {
    c.Value += x
    return c
}

func (c *Calculator) Multiply(x float64) *Calculator {
    c.Value *= x
    return c
}

// Usage:
result := new(Calculator).Add(5).Multiply(2).Value // 10
```

#### ইন্টারফেস ইমপ্লিমেন্টেশন

```go
type Speaker interface { Speak() string }

type Dog struct{}

func (d Dog) Speak() string { return "Woof!" }

// Dog implicitly implements Speaker
```

#### Nil Receiver হ্যান্ডলিং

```go
func (u *User) SafeGreet() string {
    if u == nil {
        return "Hello, guest!"
    }
    return fmt.Sprintf("Hello, %s", u.Name)
}

// Usage:
var emptyUser *User
fmt.Println(emptyUser.SafeGreet()) // "Hello, guest!"
```

### সাধারণ সমস্যা এবং সমাধান

1. **অসংগত Receiver Types**

   ```go
   // একই struct-এ receiver types মিশ্রিত করা এড়িয়ে চলুন
   type Product struct{}

   func (p Product) GetPrice() float64 {...}  // Value
   func (p *Product) SetPrice() {...}        // Pointer
   ```

2. **অনিচ্ছাকৃত Value কপি**

   ```go
   func (u User) UpdateName() {
       u.Name = "Changed" // অরিজিনাল পরিবর্তন হয় না!
   }
   ```

3. **Nil Pointer Panics**

   ```go
   var u *User
   u.Birthday() // Panic হবে!
   ```

4. **ধারাবাহিকতা গুরুত্বপূর্ণ**

   - প্রতিটি struct-এর জন্য একটি receiver type (value বা pointer) বেছে নিন
   - ব্যতিক্রম: যখন নির্দিষ্ট method-এ mutation capability প্রয়োজন

5. **Receiver নামকরণ**

   - ছোট (১-২ অক্ষর) এবং টাইপ সম্পর্কিত রাখুন:
     - `User`-এর জন্য `u`
     - `Client`-এর জন্য `c`
     - `Database`-এর জন্য `db`

6. **সাইজ বিবেচনা**

   ```go
   // বড় structs-এর জন্য pointer receiver ব্যবহার করুন
   type BigData struct {
       data [1_000_000]int
   }

   func (b *BigData) Process() {...} // মেমোরির জন্য ভালো
   ```

## মনে রাখার কৌশল

- **V**alue receiver = **V**iew-only (শুধু দেখার জন্য)
- **P**ointer receiver = **P**ermission to modify (পরিবর্তনের অনুমতি)
- `(t T)` = "একটি কপি নাও"
- `(t *T)` = "অরিজিনালটি নাও"
