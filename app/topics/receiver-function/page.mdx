### Receiver Functions in Go

### What Are Receiver Functions?

Receiver functions allow you to define methods on types. They're Go's way of attaching functionality to structs (or any user-defined type).

```go
type User struct {
    Name string
    Age  int
}

// Receiver function
func (u User) Greet() string {
    return fmt.Sprintf("Hello, %s!", u.Name)
}
```

## Basic Syntax

```go
func (receiverName ReceiverType) MethodName(parameters) returnTypes {
    // Method body
}
```

## Value vs Pointer Receivers

| Feature          | Value Receiver (`u User`) | Pointer Receiver (`u *User`) |
|------------------|--------------------------|-----------------------------|
| Modifies original | ❌ No                   | ✅ Yes                      |
| Memory efficiency | Copies value            | Uses reference             |
| Usage             | Immutable operations   | Mutating operations        |

```go
// Value receiver (read-only)
func (u User) GetAge() int {
    return u.Age
}

// Pointer receiver (can modify)
func (u *User) Birthday() {
    u.Age++
}
```

## FAQ: Common Interview Questions

### 1. When to use pointer receivers?
**A:** Use when:
- You need to modify the receiver
- Working with large structs (avoid copying)
- Implementing interface methods that require mutation

### 2. Can any type have methods?
**A:** Yes, but with restrictions:
```go
type MyInt int

func (m MyInt) Double() int {
    return int(m * 2)
}
```
**Exception:** Cannot define methods on:
- Built-in types directly (must alias)
- Pointers directly
- Interfaces

### 3. What's the convention for receiver names?
**A:** Typically 1-2 letters matching type:
- `u` for `User`
- `p` for `Product`
- `c` for `Client`

### 4. Can interfaces have receiver methods?
**A:** No, interfaces define method signatures but can't implement them.

## Practical Patterns

### Method Chaining
```go
type Calculator struct { Value float64 }

func (c *Calculator) Add(x float64) *Calculator {
    c.Value += x
    return c
}

func (c *Calculator) Multiply(x float64) *Calculator {
    c.Value *= x
    return c
}

// Usage:
result := new(Calculator).Add(5).Multiply(2).Value // 10
```

### Interface Implementation
```go
type Speaker interface { Speak() string }

type Dog struct{}

func (d Dog) Speak() string { return "Woof!" }

// Dog implicitly implements Speaker
```

## Common Pitfalls

1. **Mixing receiver types**:
   ```go
   type User struct {}
   
   func (u User) A()  {}
   func (u *User) B() {} // Inconsistent - avoid!
   ```

2. **Nil receivers**:
   ```go
   var u *User
   u.Birthday() // Runtime panic!
   ```

3. **Overusing methods**:
   - When a standalone function would suffice
   - When the method doesn't logically belong to the type

## Best Practices

1. **Be consistent**:
   - Use either value or pointer receivers for all methods of a type

2. **Small focused methods**:
   - Keep methods under 10 lines where possible

3. **Document receiver nil-safety**:
   ```go
   // Greet returns a greeting string
   // Safe to call on nil receiver
   func (u *User) Greet() string {
       if u == nil {
           return "Hello, guest!"
       }
       return fmt.Sprintf("Hello, %s", u.Name)
   }
   ```

## Memory Aid
- **V**alue receiver = **V**iew-only
- **P**ointer receiver = **P**ermission to modify
- `(t T)` = "Take a copy"
- `(t *T)` = "Take the original"