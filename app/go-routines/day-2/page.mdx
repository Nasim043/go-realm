‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá, Day 2 ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶≤‡ßã ‚Äî ‡¶Ü‡¶ú ‡¶Ü‡¶Æ‡¶∞‡¶æ **Channels** ‡¶∂‡¶ø‡¶ñ‡¶¨‡•§
‡¶Ü‡¶Æ‡¶ø ‡¶ß‡ßÄ‡¶∞‡ßá ‡¶ß‡ßÄ‡¶∞‡ßá, ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ + ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ + ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡¶∏‡¶π ‡¶¶‡ßá‡¶ñ‡¶æ‡¶ö‡ßç‡¶õ‡¶ø‡•§

---

## üçÄ Channels ‡¶ï‡ßÄ?

**Channel** ‡¶π‡¶≤‡ßã Go-‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø built-in data pipe, ‡¶Ø‡¶æ **goroutine** ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá **‡¶°‡¶æ‡¶ü‡¶æ ‡¶Ü‡¶¶‡¶æ‡¶®-‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶®**‡¶ï‡ßá **‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶** ‡¶ì **‡¶∏‡¶Æ‡¶®‡ßç‡¶¨‡¶ø‡¶§ (synchronized)** ‡¶ï‡¶∞‡ßá‡•§

Go ‡¶¨‡¶≤‡ßá:

> ‚ÄúDon‚Äôt communicate by sharing memory; share memory by communicating.‚Äù

‡¶Æ‡¶æ‡¶®‡ßá: ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá memory-‡¶§‡ßá read/write ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá, **‡¶°‡ßá‡¶ü‡¶æ channel ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡ßã** ‚Äî ‡¶§‡¶æ‡¶§‡ßá ‡¶≤‡¶ï (mutex) ‡¶®‡¶æ ‡¶≤‡¶æ‡¶ó‡¶≤‡ßá‡¶ì concurrency safe ‡¶•‡¶æ‡¶ï‡ßá‡•§

---

## 1) Channel ‡¶§‡ßà‡¶∞‡¶ø

```go
ch := make(chan int)
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá `ch` ‡¶∂‡ßÅ‡¶ß‡ßÅ **int** send/receive ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§

---

## 2) Send & Receive (Unbuffered Channel)

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch <- 10  // send
    }()

    value := <-ch // receive
    fmt.Println(value)
}
```

### ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßÄ ‡¶π‡¶ö‡ßç‡¶õ‡ßá?

* Sender `ch <- 10` ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶è‡¶∏‡ßá **receiver ‡¶®‡¶æ ‡¶Ü‡¶∏‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá**‡•§
* Receiver `<-ch` ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶è‡¶∏‡ßá **sender ‡¶®‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá**‡•§

**‚û°Ô∏è Unbuffered channel sender ‡¶è‡¶¨‡¶Ç receiver ‡¶¶‡ßÅ‡¶á‡¶ú‡¶®‡¶ï‡ßá‡¶á ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ‡ßü ‡¶∞‡¶æ‡¶ñ‡ßá = synchronization**

---

## 3) Buffered Channel

```go
ch := make(chan int, 2)
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá channel-‡¶è‡¶∞ capacity = 2‡•§

```go
package main
import "fmt"

func main() {
    ch := make(chan int, 2)

    ch <- 1
    ch <- 2  // OK, buffer full
    // ch <- 3 // ‡¶è‡¶ñ‡¶æ‡¶®‡ßá deadlock, ‡¶ï‡¶æ‡¶∞‡¶£ buffer ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‚Üí receiver ‡¶®‡ßá‡¶á

    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

### ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ( Timing ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ )

| ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤    | ‡¶Ü‡¶ö‡¶∞‡¶£                                             |
| ---------- | ------------------------------------------------ |
| Unbuffered | Send ‡¶ì Receive ‡¶¶‡ßÅ‡¶ú‡¶®‡¶á ‡¶è‡¶ï‡ßá ‡¶Ö‡¶™‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá  |
| Buffered   | ‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ buffer-‡¶è ‡¶ú‡¶æ‡ßü‡¶ó‡¶æ ‡¶Ü‡¶õ‡ßá, sender ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ |

---

## 4) Channel ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ (close)

```go
close(ch)
```

### ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ ‡¶ï‡ßá‡¶® ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?

‚ô¶Ô∏è ‡¶¨‡ßã‡¶ù‡¶æ‡¶§‡ßá ‡¶Ø‡ßá **‡¶Ü‡¶∞ ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶∏‡¶¨‡ßá ‡¶®‡¶æ**‡•§

### Channel-‡¶è‡¶∞ ‡¶ì‡¶™‡¶∞ loop ‡¶ï‡¶∞‡¶æ (for-range):

```go
for v := range ch {
    fmt.Println(v)
}
```

---

## ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ßß: Unbuffered Channel (Sender ‚Üí Receiver)

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch <- 5
    }()

    fmt.Println(<-ch)
}
```

---

## ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ß®: Buffered ‡¶è ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ì ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø

```go
package main
import "fmt"

func main() {
    ch := make(chan int, 1)

    ch <- 10 // ‡¶è‡¶ñ‡¶®‡¶á send ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡ßü, ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶≤‡¶æ‡¶ó‡ßá ‡¶®‡¶æ
    fmt.Println("Sent!")

    fmt.Println(<-ch)
}
```

Unbuffered ‡¶π‡¶≤‡ßá `Sent!` ‡¶¶‡ßá‡¶ñ‡¶æ‡¶§‡ßá receiver ‡¶≤‡¶æ‡¶ó‡¶§‡ßã‡•§
Buffered ‡¶π‡¶≤‡ßá sender **block** ‡¶π‡ßü ‡¶®‡¶æ (buffer full ‡¶®‡¶æ ‡¶π‡¶ì‡ßü‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§)‡•§

---

## ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ß©: Channel ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ + range

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch {
        fmt.Println(v)
    }
}
```

---

## ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ß™: 10 ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶ì ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßã

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        for i := 1; i <= 10; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch {
        fmt.Println(v)
    }
}
```

---

## ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ß´: Pipeline (Generator ‚Üí Doubler ‚Üí Main)

```go
package main
import "fmt"

func generate(ch chan int) {
    for i := 1; i <= 5; i++ {
        ch <- i
    }
    close(ch)
}

func double(in chan int) chan int {
    out := make(chan int)
    go func() {
        for v := range in {
            out <- v * 2
        }
        close(out)
    }()
    return out
}

func main() {
    ch := make(chan int)
    go generate(ch)

    out := double(ch)

    for v := range out {
        fmt.Println(v)
    }
}
```

---

## ‚ö†Ô∏è ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶≠‡ßÅ‡¶≤ (Deadlocks & Closing Issues)

| ‡¶≠‡ßÅ‡¶≤                           | ‡¶´‡¶≤‡¶æ‡¶´‡¶≤                                 |
| ----------------------------- | ------------------------------------- |
| Receiver ‡¶®‡ßá‡¶á ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Send ‡¶ï‡¶∞‡¶æ  | Deadlock                              |
| Send ‡¶®‡ßá‡¶á ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Receive ‡¶ï‡¶∞‡¶æ   | Deadlock                              |
| ‡¶¨‡¶®‡ßç‡¶ß channel-‡¶è ‡¶Ü‡¶¨‡¶æ‡¶∞ send ‡¶ï‡¶∞‡¶æ  | panic                                 |
| ‡¶¨‡¶®‡ßç‡¶ß channel ‡¶•‡ßá‡¶ï‡ßá receive ‡¶ï‡¶∞‡¶æ | OK, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ zero-value ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá |

---

## üß© ‡¶ö‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶û‡ßç‡¶ú ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® (Deadlock ‡¶ö‡¶ø‡¶®‡ßá ‡¶ß‡¶∞‡¶æ)

‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶ï‡ßã‡¶°‡ßá ‡¶ï‡¶ø ‡¶π‡¶¨‡ßá? ‡¶ï‡ßá‡¶®?

```go
package main
import "fmt"

func main() {
    ch := make(chan int)
    ch <- 1
    fmt.Println(<-ch)
}
```

**‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶®‡¶ø‡¶ú‡ßá ‡¶¨‡¶≤‡¶¨‡ßá‡•§**
(‡¶á‡¶ô‡ßç‡¶ó‡¶ø‡¶§: receiver ‡¶ï‡ßã‡¶•‡¶æ‡ßü?)

---

## üìù Channel Rules Summary (5 Points)

1. Channels goroutine ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá **safe communication** ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßá‡•§
2. Unbuffered channel send-receive **synchronize** ‡¶ï‡¶∞‡ßá (‡¶¶‡ßÅ‡¶ú‡¶® ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá)‡•§
3. Buffered channel buffer capacity ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ **non-blocking** send ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡ßá‡ßü‡•§
4. Channel ‡¶¨‡¶®‡ßç‡¶ß (`close(ch)`) ‡¶Æ‡¶æ‡¶®‡ßá **‡¶Ü‡¶∞ ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶∏‡¶¨‡ßá ‡¶®‡¶æ**; receiver `range` ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡ßú‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§
5. **Deadlock** = send/receive ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶¨‡¶ø‡¶™‡¶∞‡ßÄ‡¶§ ‡¶™‡¶ï‡ßç‡¶∑ ‡¶®‡ßá‡¶á‡•§

---

### üéØ ‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶ï‡¶æ‡¶ú:

‡¶â‡¶™‡¶∞‡ßá‡¶∞ **‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡ßß-‡ß´** ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü ‡¶¶‡ßá‡¶ñ‡ßá ‡¶¶‡¶æ‡¶ì‡•§
‡¶§‡¶æ‡¶∞‡¶™‡¶∞ **‡¶ö‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶û‡ßç‡¶ú ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞** ‡¶Ü‡¶Æ‡¶æ‡¶ï‡ßá ‡¶¶‡¶æ‡¶ì ‚Äî ‡¶Ü‡¶Æ‡¶ø ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶¨‡•§


‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá ‚Äî ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶∞‡¶ì **‡¶ó‡¶≠‡ßÄ‡¶∞‡¶≠‡¶æ‡¶¨‡ßá** ‡¶∂‡¶ø‡¶ñ‡¶¨‡•§
‡¶è‡¶¨‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶π‡¶¨‡ßá ‡¶ñ‡ßÅ‡¶¨ **‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤ + visualization + timing flow ‡¶∏‡¶π**‡•§

---

# ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤: ‡¶ó‡¶≠‡ßÄ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ

## ‡¶ï‡ßá‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?

‡¶ß‡¶∞‡ßã, ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ goroutine ‡¶è‡¶ï‡¶á variable-‡¶è write ‡¶ï‡¶∞‡¶õ‡ßá:

```
x = x + 1
```

‡¶Ø‡¶¶‡¶ø ‡¶¶‡ßÅ‡¶ú‡¶® ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶≤‡ßá‡¶ñ‡ßá, ‡¶§‡¶ñ‡¶® value corrupt ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá (race condition)‡•§

‡¶è‡¶ü‡¶ø ‡¶è‡¶≠‡¶æ‡¶¨‡ßá fix ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü:

* Mutex lock
* Atomic operations
* Shared memory coordination

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Go ‡¶¨‡¶≤‡ßá:

> ‚ÄúDon‚Äôt communicate by sharing memory; share memory by communicating.‚Äù

‡¶Æ‡¶æ‡¶®‡ßá:
**Variable share ‡¶ï‡¶∞‡ßã ‡¶®‡¶æ‡•§ Data ‡¶™‡¶æ‡¶†‡¶æ‡¶ì‡•§ ‡¶§‡¶æ‡¶π‡¶≤‡ßá‡¶á code naturally safe ‡¶•‡¶æ‡¶ï‡ßá‡•§**

‡¶è‡¶ú‡¶®‡ßç‡¶Ø‡¶á **channel** ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

---

# 1) Channel ‡¶§‡ßà‡¶∞‡¶ø

```go
ch := make(chan int)    // unbuffered
ch2 := make(chan string, 3)  // buffered, capacity 3
```

## Channel internal model:

```
Sender  ‚Üí  [ Channel ]  ‚Üí Receiver
```

Channel ‡¶®‡¶ø‡¶ú‡ßá‡¶á data queue ‡¶ß‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá (buffer ‡¶•‡¶æ‡¶ï‡¶≤‡ßá queue ‡¶¨‡ßú ‡¶π‡ßü)‡•§

---

# 2) Sending ‡¶ì Receiving ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§

### Send:

```go
ch <- x
```

### Receive:

```go
v := <-ch
```

Unbuffered channel-‡¶è:

```
Sender send ‡¶ï‡¶∞‡¶§‡ßá ‡¶ó‡¶ø‡ßü‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‚è≥
Receiver receive ‡¶ï‡¶∞‡¶§‡ßá ‡¶ó‡¶ø‡ßü‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‚è≥
```

‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßÅ‡¶ú‡¶® **‡¶Æ‡¶ø‡¶≤‡¶¨‡ßá**, ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡ßá‡¶á data transfer ‡¶π‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶¶‡ßÅ‡¶ú‡¶®‡¶á **release** ‡¶π‡¶¨‡ßá‡•§

### Unbuffered Timing Diagram

```
Time ‚Üí
Sender:   ----[ Send(n) ]------ wait ----> paired ----> done
Receiver: -------- wait --------[ Receive ]------------> done
```

### ‡¶Ö‡¶∞‡ßç‡¶•:

Sender ‡¶ì Receiver **‡¶è‡¶ï‡¶á ‡¶∏‡¶Æ‡ßü** data exchange ‡¶ï‡¶∞‡ßá‡•§
‡¶è‡¶ü‡¶æ **handshake-like** synchronization‡•§

---

# 3) Buffered Channel ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§

```go
ch := make(chan int, 2)
```

Buffer = Queue = Channel-‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá memory‡•§

### Buffered Timing Diagram

```
Initial: [ empty ]
Send ‚Üí [ 1 ]
Send ‚Üí [ 1, 2 ] (full now)
Next Send ‚Üí block! (receiver needed here)
```

Receiver:

```
Receive ‚Üí pops 1 ‚Üí [ 2 ]
Receive ‚Üí pops 2 ‚Üí [ empty ]
```

### ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™‡ßá:

| ‡¶ß‡¶∞‡¶£        | ‡¶ï‡¶¨‡ßá send block ‡¶π‡ßü?          | ‡¶ï‡¶¨‡ßá receive block ‡¶π‡ßü?       |
| ---------- | --------------------------- | --------------------------- |
| Unbuffered | ‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ receiver ready ‡¶®‡¶æ ‡¶π‡ßü | ‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ sender ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶®‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡ßü |
| Buffered   | Buffer ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶π‡¶≤‡ßá            | Buffer ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶π‡¶≤‡ßá             |

---

# 4) Channel ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ (close)

```go
close(ch)
```

Close ‡¶ï‡¶∞‡¶æ ‡¶Æ‡¶æ‡¶®‡ßá:

* ‡¶Ü‡¶∞ **send** ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ (send ‡¶ï‡¶∞‡¶≤‡ßá panic)
* ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ receive ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá (zero-value + ok flag)

### Receive with ok flag:

```go
v, ok := <-ch
if !ok {
    fmt.Println("Channel closed")
}
```

### Range ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞:

```go
for v := range ch {
    fmt.Println(v)
}
```

`range` channel close ‡¶π‡¶ì‡ßü‡¶æ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶ö‡¶≤‡¶¨‡ßá‡•§

---

# 5) Channel-‡¶è‡¶∞ ‡¶Ü‡¶ï‡¶æ‡¶∞ ‡¶¶‡ßá‡¶ñ‡¶æ

```go
len(ch) // buffer ‡¶è ‡¶ï‡ßü‡¶ü‡¶æ item ‡¶Ü‡¶õ‡ßá
cap(ch) // buffer capacity
```

‡¶â‡¶™‡¶ï‡¶æ‡¶∞‡ßÄ debugging ‡¶è‡•§

---

# 6) ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶≠‡ßÅ‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã (‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶Ö‡¶Ç‡¶∂)

| ‡¶≠‡ßÅ‡¶≤                            | ‡¶´‡¶≤‡¶æ‡¶´‡¶≤         | ‡¶ï‡ßá‡¶®                           |
| ------------------------------ | ------------- | ----------------------------- |
| Receive ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Send ‡¶®‡ßá‡¶á    | Deadlock      | ‡¶ï‡ßá‡¶â data ‡¶™‡¶æ‡¶†‡¶æ‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ          |
| Send ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Receive ‡¶®‡ßá‡¶á    | Deadlock      | channel overflow (unbuffered) |
| Buffered full, but no receiver | Deadlock      | buffer ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá         |
| Close ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞ send             | Panic         | ‡¶¨‡¶®‡ßç‡¶ß channel-‡¶è ‡¶≤‡ßá‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ    |
| Close ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá range ‡¶ï‡¶∞‡¶≤‡ßá        | Infinite wait | ‡¶ï‡¶ñ‡¶®‡ßã close ‡¶ß‡¶∞‡¶¨‡ßá ‡¶®‡¶æ            |

---

# ‚úÖ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® (‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∏‡¶π)

### 1) Unbuffered Channel Synchronization Proof

```go
package main
import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    go func() {
        fmt.Println("Sender: preparing")
        time.Sleep(2 * time.Second)
        fmt.Println("Sender: sending")
        ch <- "Hello"
        fmt.Println("Sender: done send")
    }()

    time.Sleep(1 * time.Second)
    fmt.Println("Receiver: waiting...")
    msg := <-ch
    fmt.Println("Receiver got:", msg)
}
```

**Output reasoning:**

```
Sender: preparing
Receiver: waiting...
Sender: sending
Receiver got: Hello
Sender: done send
```

‡¶¶‡ßá‡¶ñ‡ßã send ‡¶è‡¶¨‡¶Ç receive **handshake** ‡¶è‡¶∞ ‡¶Æ‡¶§ synchronized‡•§

---

### 2) Buffered Example Timing

```go
package main
import "fmt"

func main() {
    ch := make(chan int, 2)
    ch <- 1
    ch <- 2
    fmt.Println("Sent 2 values without waiting.")
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

---

### 3) Close + Range

```go
package main
import "fmt"

func main() {
    ch := make(chan int)
    go func() {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch)
    }()
    for v := range ch {
        fmt.Println(v)
    }
}
```

---

### 4) 10 ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã

```go
for i := 1; i <= 10; i++ { ch <- i }
```

---

### 5) Pipeline (Generator ‚Üí Doubler)

```go
// Already shown above ‚Äî keep practicing
```

---

# üß© ‡¶ö‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶û‡ßç‡¶ú ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® (Deadlock ‡¶ö‡¶ø‡¶®‡ßá ‡¶ß‡¶∞‡¶æ)

```go
package main
import "fmt"

func main() {
    ch := make(chan int)
    ch <- 1        // ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßÄ ‡¶π‡¶¨‡ßá?
    fmt.Println(<-ch)
}
```

**‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ú: ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶æ‡¶ì ‚Äî ‡¶ï‡ßá‡¶® deadlock ‡¶π‡¶¨‡ßá/‡¶π‡¶¨‡ßá ‡¶®‡¶æ?**

---

# ‚úÖ 5-‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü Final Summary (Notes)

1. Channel goroutine ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá **safe data transfer** ‡¶ï‡¶∞‡ßá‡•§
2. Unbuffered channel send & receive **synchronize** ‡¶ï‡¶∞‡ßá‡•§
3. Buffered channel capacity ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ send non-blocking ‡¶π‡ßü‡•§
4. `close(ch)` ‡¶Æ‡¶æ‡¶®‡ßá **‡¶Ü‡¶∞ send ‡¶®‡ßü**, ‡¶§‡¶¨‡ßá receive/`range` ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§
5. Deadlock ‡¶π‡ßü ‡¶Ø‡¶ñ‡¶® **send/receive ‡¶â‡¶≠‡ßü‡ßá‡¶∞ ‡¶¨‡¶ø‡¶™‡¶∞‡ßÄ‡¶§ ‡¶™‡¶ï‡ßç‡¶∑ ‡¶Ö‡¶®‡ßÅ‡¶™‡¶∏‡ßç‡¶•‡¶ø‡¶§ ‡¶•‡¶æ‡¶ï‡ßá**‡•§

---

‡¶Ø‡¶ñ‡¶® ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‚Äî **‡¶ö‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶û‡ßç‡¶ú ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶æ‡¶ì**‡•§
‡¶Ü‡¶Æ‡¶ø ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶¨ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶∞‡¶™‡¶∞ Day 3 ‡¶¶‡ßá‡¶¨ (Select, Fan-In / Fan-Out, Worker Pools)‡•§
