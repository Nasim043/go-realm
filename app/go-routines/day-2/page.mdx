## ЁЯНА Channels ржХрзА?
Goroutine ржЧрзБрж▓рзЛ рж╕рзНржмрж╛ржзрзАржиржнрж╛ржмрзЗ ржЪрж▓рзЗ, рждрж╛ржЗ рждрж╛ржжрзЗрж░ ржоржзрзНржпрзЗ рждржерзНржп ржЖржжрж╛ржи-ржкрзНрж░ржжрж╛ржи ржмрж╛ рж╕рж┐ржЩрзНржХрзНрж░рзЛржирж╛ржЗржЬрзЗрж╢ржирзЗрж░ (Sync) ржЬржирзНржп ржжрж░ржХрж╛рж░ рж╣рзЯ ржПржХржЯрж┐ **safe communication mechanism**ред

**Channel** рж╣ржЪрзНржЫрзЗ рж╕рзЗржЗ ржирж┐рж░рж╛ржкржж ржкрж╛ржЗржкрж▓рж╛ржЗржи, ржпрзЗржЦрж╛ржирзЗ:

* ржПржХ Goroutine рждржерзНржп ржкрж╛ржарж╛рзЯ (`chan <-`)
* ржЕржирзНржп Goroutine рждржерзНржп ржЧрзНрж░рж╣ржг ржХрж░рзЗ (`<- chan`)

**channel** ржжрж┐рзЯрзЗ ржЧрзЛрж░рзБржЯрж┐ржиржЧрзБрж▓рзЛ ржПржХрзЗ ржЕржкрж░рзЗрж░ рж╕рж╛ржерзЗ "ржХржерж╛ ржмрж▓рзЗ"ред

Go ржмрж▓рзЗ:

> тАЬDonтАЩt communicate by sharing memory; share memory by communicating.тАЭ

ржорж╛ржирзЗ: ржПржХрж╕рж╛ржерзЗ memory-рждрзЗ read/write ржирж╛ ржХрж░рзЗ, **ржбрзЗржЯрж╛ channel ржжрж┐рзЯрзЗ ржкрж╛рж╕ ржХрж░рзЛ** тАФ рждрж╛рждрзЗ рж▓ржХ (mutex) ржирж╛ рж▓рж╛ржЧрж▓рзЗржУ concurrency safe ржерж╛ржХрзЗред


## ржХрзЗржи ржЪрзНржпрж╛ржирзЗрж▓ ржжрж░ржХрж╛рж░?

ржзрж░рзЛ, ржжрзБржЗржЯрж╛ goroutine ржПржХржЗ variable-ржП write ржХрж░ржЫрзЗ:

```
x = x + 1
```

ржпржжрж┐ ржжрзБржЬржи ржПржХрж╕рж╛ржерзЗ рж▓рзЗржЦрзЗ, рждржЦржи value corrupt рж╣рждрзЗ ржкрж╛рж░рзЗ (race condition)ред

ржПржЯрж┐ ржПржнрж╛ржмрзЗ fix ржХрж░рж╛ ржпрж╛рзЯ:

* Mutex lock
* Atomic operations
* Shared memory coordination

ржХрж┐ржирзНрждрзБ Go ржмрж▓рзЗ:

> тАЬDonтАЩt communicate by sharing memory; share memory by communicating.тАЭ

ржорж╛ржирзЗ:
**Variable share ржХрж░рзЛ ржирж╛ред Data ржкрж╛ржарж╛ржУред рждрж╛рж╣рж▓рзЗржЗ code naturally safe ржерж╛ржХрзЗред**

ржПржЬржирзНржпржЗ **channel** ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯред

---
---

## 1) Channel рждрзИрж░рж┐

```go
ch := make(chan int)    // unbuffered
ch2 := make(chan string, 3)  // buffered, capacity 3
```
ржПржЦрж╛ржирзЗ `ch` рж╢рзБржзрзБ **int** send/receive ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗред

---

## Channel internal model:

```
Sender  тЖТ  [ Channel ]  тЖТ Receiver
```

Channel ржирж┐ржЬрзЗржЗ data queue ржзрж░рзЗ рж░рж╛ржЦрзЗ (buffer ржерж╛ржХрж▓рзЗ queue ржмрзЬ рж╣рзЯ)ред

---

### 2) Sending ржУ Receiving ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд

### Send:

```go
ch <- x
```

### Receive:

```go
v := <-ch
```

Unbuffered channel-ржП:

```
Sender send ржХрж░рждрзЗ ржЧрж┐рзЯрзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ тП│
Receiver receive ржХрж░рждрзЗ ржЧрж┐рзЯрзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ тП│
```

ржпрзЗржЦрж╛ржирзЗ ржжрзБржЬржи **ржорж┐рж▓ржмрзЗ**, рж╕рзЗржЦрж╛ржирзЗржЗ data transfer рж╣ржмрзЗ ржПржмржВ ржжрзБржЬржиржЗ **release** рж╣ржмрзЗред

### Unbuffered Timing Diagram

```
Time тЖТ
Sender:   ----[ Send(n) ]------ wait ----> paired ----> done
Receiver: -------- wait --------[ Receive ]------------> done
```
### ржЕрж░рзНрже:

Sender ржУ Receiver **ржПржХржЗ рж╕ржорзЯ** data exchange ржХрж░рзЗред
ржПржЯрж╛ **handshake-like** synchronizationред

## 2) Send & Receive (Unbuffered Channel)

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch <- 10  // send
    }()

    value := <-ch // receive
    fmt.Println(value)
}
```

### ржПржЦрж╛ржирзЗ ржХрзА рж╣ржЪрзНржЫрзЗ?

* Sender `ch <- 10` ржкрж░рзНржпржирзНржд ржПрж╕рзЗ **receiver ржирж╛ ржЖрж╕рж╛ ржкрж░рзНржпржирзНржд ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржмрзЗ**ред
* Receiver `<-ch` ржкрж░рзНржпржирзНржд ржПрж╕рзЗ **sender ржирж╛ ржкрж╛ржарж╛ржирзЛ ржкрж░рзНржпржирзНржд ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржмрзЗ**ред

**тЮбя╕П Unbuffered channel sender ржПржмржВ receiver ржжрзБржЗржЬржиржХрзЗржЗ ржЕржкрзЗржХрзНрж╖рж╛рзЯ рж░рж╛ржЦрзЗ = synchronization**

---

## 3) Buffered Channel

```go
ch := make(chan int, 2)
```
ржПржЦрж╛ржирзЗ channel-ржПрж░ capacity = 2ред
> Buffer = Queue = Channel-ржПрж░ ржнрзЗрждрж░рзЗ memoryред

```go
package main
import "fmt"

func main() {
    ch := make(chan int, 2)

    ch <- 1
    ch <- 2  // OK, buffer full
    // ch <- 3 // ржПржЦрж╛ржирзЗ deadlock, ржХрж╛рж░ржг buffer ржкрзВрж░рзНржг тЖТ receiver ржирзЗржЗ

    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

### Buffered Timing Diagram

```
Initial: [ empty ]
Send тЖТ [ 1 ]
Send тЖТ [ 1, 2 ] (full now)
Next Send тЖТ block! (receiver needed here)
```

Receiver:

```
Receive тЖТ pops 1 тЖТ [ 2 ]
Receive тЖТ pops 2 тЖТ [ empty ]
```
---

### ржкрж╛рж░рзНржержХрзНржп ( Timing ржзрж╛рж░ржгрж╛ )

| ржЪрзНржпрж╛ржирзЗрж▓    | ржЖржЪрж░ржг                                             |ржХржмрзЗ send block рж╣рзЯ?          | ржХржмрзЗ receive block рж╣рзЯ?       |
| ---------- | ------------------------------------------------ |--------------------------- | --------------------------- |
| Unbuffered | Send ржУ Receive ржжрзБржЬржиржЗ ржПржХрзЗ ржЕржкрж░рзЗрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ  |ржпрждржХрзНрж╖ржг receiver ready ржирж╛ рж╣рзЯ | ржпрждржХрзНрж╖ржг sender ржХрж┐ржЫрзБ ржирж╛ ржкрж╛ржарж╛рзЯ |
| Buffered   | ржпрждржХрзНрж╖ржг buffer-ржП ржЬрж╛рзЯржЧрж╛ ржЖржЫрзЗ, sender ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ ржирж╛ |Buffer ржкрзВрж░рзНржг рж╣рж▓рзЗ            | Buffer ржЦрж╛рж▓рж┐ рж╣рж▓рзЗ             |

---

### 4) Channel ржмржирзНржз ржХрж░рж╛ (close)

```go
close(ch)
```

Close ржХрж░рж╛ ржорж╛ржирзЗ:

* ржЖрж░ **send** ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛ (send ржХрж░рж▓рзЗ panic)
* ржХрж┐ржирзНрждрзБ receive ржХрж░рж╛ ржпрж╛ржмрзЗ (zero-value + ok flag)

### ржмржирзНржз ржХрж░рж╛ ржХрзЗржи ржжрж░ржХрж╛рж░?

тЩжя╕П ржмрзЛржЭрж╛рждрзЗ ржпрзЗ **ржЖрж░ ржбрзЗржЯрж╛ ржЖрж╕ржмрзЗ ржирж╛**ред


### Receive with ok flag:

```go
v, ok := <-ch
if !ok {
    fmt.Println("Channel closed")
}
```

### Channel-ржПрж░ ржУржкрж░ loop ржХрж░рж╛ (for-range):

```go
for v := range ch {
    fmt.Println(v)
}
```

`range` channel close рж╣ржУрзЯрж╛ ржкрж░рзНржпржирзНржд ржЪрж▓ржмрзЗред

---

### Channel-ржПрж░ ржЖржХрж╛рж░ ржжрзЗржЦрж╛

```go
len(ch) // buffer ржП ржХрзЯржЯрж╛ item ржЖржЫрзЗ
cap(ch) // buffer capacity
```

ржЙржкржХрж╛рж░рзА debugging ржПред

### рж╕рж╛ржзрж╛рж░ржг ржнрзБрж▓ржЧрзБрж▓рзЛ (рж╕ржмржЪрзЗрзЯрзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржЕржВрж╢)

| ржнрзБрж▓                            | ржлрж▓рж╛ржлрж▓         | ржХрзЗржи                           |
| ------------------------------ | ------------- | ----------------------------- |
| Receive ржЖржЫрзЗ ржХрж┐ржирзНрждрзБ Send ржирзЗржЗ    | Deadlock      | ржХрзЗржЙ data ржкрж╛ржарж╛ржЪрзНржЫрзЗ ржирж╛          |
| Send ржЖржЫрзЗ ржХрж┐ржирзНрждрзБ Receive ржирзЗржЗ    | Deadlock      | channel overflow (unbuffered) |
| Buffered full, but no receiver | Deadlock      | buffer ржкрзВрж░рзНржг рж╣рзЯрзЗ ржЧрзЗржЫрзЗ         |
| Close ржХрж░рж╛рж░ ржкрж░ send             | Panic         | ржмржирзНржз channel-ржП рж▓рзЗржЦрж╛ ржпрж╛рзЯ ржирж╛    |
| Close ржирж╛ ржХрж░рзЗ range ржХрж░рж▓рзЗ        | Infinite wait | ржХржЦржирзЛ close ржзрж░ржмрзЗ ржирж╛            |

---
###  тЬЕ ржЕржирзБрж╢рзАрж▓ржи рзз: Unbuffered Channel Synchronization Proof

```go
package main
import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    go func() {
        fmt.Println("Sender: preparing")
        time.Sleep(2 * time.Second)
        fmt.Println("Sender: sending")
        ch <- "Hello"
        fmt.Println("Sender: done send")
    }()

    time.Sleep(1 * time.Second)
    fmt.Println("Receiver: waiting...")
    msg := <-ch
    fmt.Println("Receiver got:", msg)
}
```

**Output reasoning:**

```
Sender: preparing
Receiver: waiting...
Sender: sending
Receiver got: Hello
Sender: done send
```

ржжрзЗржЦрзЛ send ржПржмржВ receive **handshake** ржПрж░ ржоржд synchronizedред

---

---

## тЬЕ ржЕржирзБрж╢рзАрж▓ржи рзи: Buffered ржП рж░рзВржкрж╛ржирзНрждрж░ ржУ ржкрж╛рж░рзНржержХрзНржп

```go
package main
import "fmt"

func main() {
    ch := make(chan int, 1)

    ch <- 10 // ржПржЦржиржЗ send рж╣рзЯрзЗ ржпрж╛рзЯ, ржЕржкрзЗржХрзНрж╖рж╛ рж▓рж╛ржЧрзЗ ржирж╛
    fmt.Println("Sent!")

    fmt.Println(<-ch)
}
```

Unbuffered рж╣рж▓рзЗ `Sent!` ржжрзЗржЦрж╛рждрзЗ receiver рж▓рж╛ржЧрждрзЛ ЁЯФеред
Buffered рж╣рж▓рзЗ sender **block** рж╣рзЯ ржирж╛ (buffer full ржирж╛ рж╣ржУрзЯрж╛ ржкрж░рзНржпржирзНржд)ред

---

## тЬЕ ржЕржирзБрж╢рзАрж▓ржи рзй: Channel ржмржирзНржз ржХрж░рж╛ + range

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch {
        fmt.Println(v)
    }
}
```

---

## тЬЕ ржЕржирзБрж╢рзАрж▓ржи рзк: 10 рж╕ржВржЦрзНржпрж╛ ржкрж╛ржарж╛ржУ ржПржмржВ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛ

```go
package main
import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        for i := 1; i <= 10; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch {
        fmt.Println(v)
    }
}
```

---

## тЬЕ ржЕржирзБрж╢рзАрж▓ржи рзл: Pipeline (Generator тЖТ Doubler тЖТ Main)

```go
package main
import "fmt"

func generate(ch chan int) {
    for i := 1; i <= 5; i++ {
        ch <- i
    }
    close(ch)
}

func double(in chan int) chan int {
    out := make(chan int)
    go func() {
        for v := range in {
            out <- v * 2
        }
        close(out)
    }()
    return out
}

func main() {
    ch := make(chan int)
    go generate(ch)

    out := double(ch)

    for v := range out {
        fmt.Println(v)
    }
}
```

---

## ЁЯзй ржЪрзНржпрж╛рж▓рзЗржЮрзНржЬ ржкрзНрж░рж╢рзНржи (ржХрзЗржи deadlock рж╣ржмрзЗ/рж╣ржмрзЗ ржирж╛?)

```go
package main
import "fmt"

func main() {
    ch := make(chan int)
    ch <- 1
    fmt.Println(<-ch)
}
```
---

## ЁЯУЭ Channel Rules Summary (5 Points)

1. Channels goroutine ржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ **safe communication** ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗред
2. Unbuffered channel send-receive **synchronize** ржХрж░рзЗ (ржжрзБржЬржи ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ)ред
3. Buffered channel buffer capacity ржкрж░рзНржпржирзНржд **non-blocking** send ржХрж░рждрзЗ ржжрзЗрзЯред
4. Channel ржмржирзНржз (`close(ch)`) ржорж╛ржирзЗ **ржЖрж░ ржбрзЗржЯрж╛ ржЖрж╕ржмрзЗ ржирж╛**; receiver `range` ржжрж┐рзЯрзЗ ржкрзЬрждрзЗ ржкрж╛рж░рзЗред
5. **Deadlock** = send/receive ржЖржЫрзЗ ржХрж┐ржирзНрждрзБ ржмрж┐ржкрж░рзАржд ржкржХрзНрж╖ ржирзЗржЗред

---