## Day 4: Select Statement & Multiplexing

`select`-ржХрзЗ ржЖржкржирж┐ `goroutine`-ржжрзЗрж░ "ржЯрзНрж░рж╛ржлрж┐ржХ ржХржирзНржЯрзНрж░рзЛрж▓рж╛рж░" ржмрж▓рждрзЗ ржкрж╛рж░рзЗржиред ржПржЯрж┐ ржПржХржЯрж┐ `goroutine`-ржХрзЗ *ржПржХрж╛ржзрж┐ржХ* ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржЙржкрж░ ржПржХржмрж╛рж░рзЗ ржиржЬрж░ рж░рж╛ржЦрждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗ ржПржмржВ ржпрзЗржЯрж┐ ржЖржЧрзЗ ржкрзНрж░рж╕рзНрждрзБржд (ready) рж╣рзЯ, рж╕рзЗржЯрж┐рж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржХрж╛ржЬ ржХрж░рзЗред


### ЁЯза ржХржирж╕рзЗржкрзНржЯ ржмрзЛржЭрж╛

### ЁЯдФ `select` ржХрзЗржи ржкрзНрж░ржпрж╝рзЛржЬржи?

ржзрж░рзБржи, ржЖржкржирж╛рж░ ржжрзБржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЫрзЗ, `ch1` ржПржмржВ `ch2`ред ржЖржкржирж┐ ржжрзБржЯрзЛ ржерзЗржХрзЗржЗ ржбрзЗржЯрж╛ ржЖрж╢рж╛ ржХрж░ржЫрзЗржиред ржЖржкржирж┐ ржпржжрж┐ ржПржнрж╛ржмрзЗ рж▓рзЗржЦрзЗржи:

```go
data1 := <-ch1 // ржПржЦрж╛ржирзЗ ржЖржЯржХрзЗ ржЧрзЗрж▓
data2 := <-ch2 // ржПржЯрж┐ ржЖрж░ ржЪрж▓ржмрзЗ ржирж╛, ржпржжрж┐ ch1 ржП ржбрзЗржЯрж╛ ржирж╛ ржЖрж╕рзЗ
```

ржпржжрж┐ `ch1`-ржП ржХрзЛржирзЛ ржбрзЗржЯрж╛ ржирж╛ ржЖрж╕рзЗ, ржХрж┐ржирзНрждрзБ `ch2`-рждрзЗ ржбрзЗржЯрж╛ ржЪрж▓рзЗ ржЖрж╕рзЗ, рждржмрзБржУ ржЖржкржирж╛рж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ЁЯФе`ch1`-ржПрж░ ржЬржирзНржп ржЕржиржирзНрждржХрж╛рж▓ ржЕржкрзЗржХрзНрж╖рж╛ (block) ржХрж░рждрзЗ ржерж╛ржХржмрзЗредЁЯФе

`select` ржПржЗ рж╕ржорж╕рзНржпрж╛рж░ рж╕ржорж╛ржзрж╛ржи ржХрж░рзЗред ржПржЯрж┐ рж╕ржм ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржжрж┐ржХрзЗ "рждрж╛ржХрж┐рзЯрзЗ" ржерж╛ржХрзЗ ржПржмржВ ржпрзЗ ржЪрзНржпрж╛ржирзЗрж▓ржЯрж┐ ржкрзНрж░ржержо ржбрзЗржЯрж╛ ржкрж╛ржарж╛рждрзЗ ржмрж╛ ржЧрзНрж░рж╣ржг ржХрж░рждрзЗ ржкрзНрж░рж╕рзНрждрзБржд рж╣рзЯ, рж╕рзЗржЯрж┐рж░ ржХрзЛржб ржмрзНрж▓ржХржЯрж┐ ржЪрж╛рж▓рж╛ржпрж╝ред

-----


### ЁЯФ╣ 1. `select` ржХрзА ржХрж░рзЗ ржПржмржВ `select` рж╕рж┐ржиржЯрзНржпрж╛ржХрзНрж╕

`select` ржЕржирзЗржХржЯрж╛ `switch` ржПрж░ ржорждрзЛ,
ржХрж┐ржирзНрждрзБ ржПржЯрж┐ ржХрж╛ржЬ ржХрж░рзЗ **ржЪрзНржпрж╛ржирзЗрж▓ ржЕржкрж╛рж░рзЗрж╢ржи** (send/receive) ржПрж░ ржЙржкрж░ред

ЁЯСЙ ржХрж╛ржЬ:
ржПржХрж╛ржзрж┐ржХ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржоржзрзНржпрзЗ **ржпрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЧрзЗ ready рж╣рзЯ**, рж╕рзЗржЯрж╛рж░ case execute рж╣рзЯред

### ЁЯУЬ `select` рж╕рж┐ржиржЯрзНржпрж╛ржХрзНрж╕ ржПржмржВ "First Ready Wins"

`select`-ржПрж░ рж╕рж┐ржиржЯрзНржпрж╛ржХрзНрж╕ `switch`-ржПрж░ ржорждрзЛржЗред

```go
select {
case data := <-ch1:
    // ch1 ржерзЗржХрзЗ ржбрзЗржЯрж╛ рж░рж┐рж╕рж┐ржн рж╣рж▓рзЗ ржПржЯрж┐ ржЪрж▓ржмрзЗ
    fmt.Println("ch1 ржерзЗржХрзЗ ржкрзЗрж▓рж╛ржо:", data)
case ch2 <- "Hi":
    // ch2-рждрзЗ ржбрзЗржЯрж╛ рж╕рзЗржирзНржб ржХрж░рж╛ рж╕ржорзНржнржм рж╣рж▓рзЗ ржПржЯрж┐ ржЪрж▓ржмрзЗ
    fmt.Println("ch2-рждрзЗ 'Hi' ржкрж╛ржарж╛рж▓рж╛ржо")
case <-ch3:
    // ch3 ржерзЗржХрзЗ ржбрзЗржЯрж╛ рж░рж┐рж╕рж┐ржн рж╣рж▓рзЗ (ржХрж┐ржирзНрждрзБ ржбрзЗржЯрж╛ ржмрзНржпржмрж╣рж╛рж░ ржирж╛ ржХрж░рж▓рзЗ)
    fmt.Println("ch3 ржерзЗржХрзЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрзЗрж▓рж╛ржо")
}
```
---

#### ЁЯЪж ржЪрж┐рждрзНрж░: `select` ржпрзЗржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ

`select` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржХрзЗ ржПржХржЯрж┐ ржлрж╛ржирзЗрж▓ рж╣рж┐рж╕рзЗржмрзЗ ржнрж╛ржмрзБржи:

```
           [goroutine]
               |
          <--select-->
         /      |     \
        /       |      \
   (ржЕржкрзЗржХрзНрж╖рж╛) (ржкрзНрж░рж╕рзНрждрзБржд) (ржЕржкрзЗржХрзНрж╖рж╛)
      |         |        |
    [ch1]     [ch2]    [ch3]
```

  * `select` рждрж┐ржиржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржжрж┐ржХрзЗржЗ ржиржЬрж░ рж░рж╛ржЦрзЗред
  * ржзрж░рзБржи, `ch2` ржкрзНрж░ржержорзЗ ржбрзЗржЯрж╛ рж░рж┐рж╕рж┐ржн ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░рж╕рзНрждрзБржд рж╣рж▓рзЛред
  * `select` *ржЕржмрж┐рж▓ржорзНржмрзЗ* `ch2`-ржПрж░ `case` ржмрзНрж▓ржХржЯрж┐ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░ржмрзЗ ржПржмржВ ржЪрж╛рж▓рж╛ржмрзЗред ржЕржирзНржп `case`-ржЧрзБрж▓рзЛ ржЙржкрзЗржХрзНрж╖рж╛ ржХрж░рж╛ рж╣ржмрзЗред
  * **"First Ready Wins"**: ржПржЯрж┐ржЗ ржорзВрж▓ ржирж┐ржпрж╝ржоред ржпрзЗ ржкрзНрж░ржержо ржкрзНрж░рж╕рзНрждрзБржд рж╣ржмрзЗ, рж╕рзЗржЗ ржЬрж┐рждржмрзЗред
  * ржпржжрж┐ ржПржХрж╛ржзрж┐ржХ `case` *ржПржХржЗ рж╕рж╛ржерзЗ* ржкрзНрж░рж╕рзНрждрзБржд ржерж╛ржХрзЗ (ржЦрзБржм ржмрж┐рж░рж▓, рждржмрзЗ рж╕ржорзНржнржм), `select` рждржЦржи рждрж╛ржжрзЗрж░ ржоржзрзНржпрзЗ ржерзЗржХрзЗ *ржПрж▓рзЛржорзЗрж▓рзЛржнрж╛ржмрзЗ* (randomly) ржПржХржЯрж┐ржХрзЗ ржмрзЗржЫрзЗ ржирзЗржпрж╝ред ржПржЯрж┐ ржХрзЛржирзЛ ржПржХржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржкрзНрж░рждрж┐ ржкржХрзНрж╖ржкрж╛ржд (bias) ржжрзВрж░ ржХрж░рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗред

-----

### ЁЯФ╣ 2. `select` ржПрж░ рж░рзБрж▓: тАЬFirst Ready WinsтАЭ

* ржПржХрж╛ржзрж┐ржХ ржЪрзНржпрж╛ржирзЗрж▓ ready ржерж╛ржХрж▓рзЗ тЖТ Go рж░тАНрзНржпрж╛ржирзНржбржорж▓рж┐ ржПржХржЯрж┐ ржмрзЗржЫрзЗ ржирзЗрзЯред
* ржХрзЛржирзЛ ржЪрзНржпрж╛ржирзЗрж▓ ready ржирж╛ ржерж╛ржХрж▓рзЗ тЖТ ржмрзНрж▓ржХ ржХрж░рзЗ (ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ)ред
* ржпржжрж┐ `default` ржерж╛ржХрзЗ тЖТ ржмрзНрж▓ржХ ржХрж░рзЗ ржирж╛ред
* ржПржХржмрж╛рж░рзЗ рж╢рзБржзрзБ ржПржХржЯрж╛ржЗ case ржЪрж▓рзЗред

---

### ЁЯФ╣ 3. ЁЯТи ржиржи-ржмрзНрж▓ржХрж┐ржВ ржЕржкрж╛рж░рзЗрж╢ржи: `default`

ржпржжрж┐ ржЖржкржирж┐ ржЪрж╛ржи ржпрзЗ `select` ржХрзЛржирзЛ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржЬржирзНржп *ржПржХржЯрзБржУ* ржЕржкрзЗржХрзНрж╖рж╛ ржирж╛ ржХрж░рзБржХ, рждржмрзЗ `default` ржХрзЗрж╕ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗржиред

ЁЯзй `default` ржХрзЗрж╕ рждржЦржиржЗ ржЪрж▓рзЗ ржпржЦржи *ржЕржирзНржп ржХрзЛржирзЛ `case`* рждрж╛рзОржХрзНрж╖ржгрж┐ржХржнрж╛ржмрзЗ ржкрзНрж░рж╕рзНрждрзБржд ржерж╛ржХрзЗ ржирж╛ред

```go
select {
case data := <-ch:
    fmt.Println("ржбрзЗржЯрж╛ рж░рж┐рж╕рж┐ржнржб:", data)
default:
    // ржХрзЛржирзЛ ржЪрзНржпрж╛ржирзЗрж▓ рж░рзЗржбрж┐ ржирж╛ ржерж╛ржХрж▓рзЗ ржПржЯрж┐ рж╕рж╛ржерзЗ рж╕рж╛ржерзЗ ржЪрж▓ржмрзЗ
    fmt.Println("ржПржЦржирзЛ ржХрзЛржирзЛ ржбрзЗржЯрж╛ ржирзЗржЗ, ржЖржорж┐ ржЕржирзНржп ржХрж╛ржЬ ржХрж░ржЫрж┐...")
}
```

ржПржЯрж┐ "try-receive" ржмрж╛ "non-blocking receive" ржХрж░рж╛рж░ ржПржХржЯрж┐ рж╕рж╣ржЬ ржЙржкрж╛ржпрж╝ред

-----
### ЁЯФ╣ 4. тП│ `time.After` ржжрж┐рзЯрзЗ ржЯрж╛ржЗржоржЖржЙржЯ (Timeout)

ржЕржирзЗржХ рж╕ржорзЯ ржЖржорж░рж╛ ржЕржиржирзНрждржХрж╛рж▓ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рждрзЗ ржЪрж╛ржЗ ржирж╛ред ржЖржорж░рж╛ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржоржпрж╝ ржкрж░рзНржпржирзНржд ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред `time.After(duration)` ржПржХржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ, ржпрж╛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржоржпрж╝ (duration) ржкрж╛рж░ рж╣ржУржпрж╝рж╛рж░ ржкрж░ *ржПржХржЯрж┐* рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржарж╛ржпрж╝ред

ржПржЯрж┐ `select`-ржПрж░ рж╕рж╛ржерзЗ ржЯрж╛ржЗржоржЖржЙржЯ рждрзИрж░рж┐рж░ ржЬржирзНржп ржжрзБрж░рзНржжрж╛ржирзНржд:

```go
select {
case data := <-longRunningTaskCh:
    fmt.Println("ржХрж╛ржЬ рж╕ржорзНржкржирзНржи:", data)
case <-time.After(2 * time.Second):
    // 2 рж╕рзЗржХрзЗржирзНржб ржкрж╛рж░ рж╣ржпрж╝рзЗ ржЧрзЗрж▓рзЗ ржПржЯрж┐ ржЪрж▓ржмрзЗ
    fmt.Println("ржЯрж╛ржЗржоржЖржЙржЯ! ржЖрж░ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рж╛ рж╕ржорзНржнржм ржирж╛ред")
}
```

> ржПржЯрж┐ ржПржХржЯрж┐ ржХрзНрж▓рж╛рж╕рж┐ржХ ржкрзНржпрж╛ржЯрж╛рж░рзНржи: рж╣ржпрж╝ ржХрж╛ржЬржЯрж┐ рж╕ржорзНржкржирзНржи рж╣ржмрзЗ, ржЕржержмрж╛ ржЯрж╛ржЗржоржЖржЙржЯ рж╣ржмрзЗтАФржжрзБржЯрж┐рж░ ржоржзрзНржпрзЗ ЁЯФержпрзЗржЯрж┐ *ржЖржЧрзЗ* ржШржЯржмрзЗредЁЯФе

-----

### ЁЯФА ржкрзНржпрж╛ржЯрж╛рж░рзНржи: ржлрзНржпрж╛ржи-ржЗржи (Fan-In) / ржорж╛рж▓рзНржЯрж┐ржкрзНрж▓рзЗржХрзНрж╕рж┐ржВ

ржлрзНржпрж╛ржи-ржЗржи рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржпрзЗржЦрж╛ржирзЗ ржЖржкржирж┐ ржПржХрж╛ржзрж┐ржХ ржЗржиржкрзБржЯ ржЪрзНржпрж╛ржирзЗрж▓ ржерзЗржХрзЗ ржбрзЗржЯрж╛ ржирж┐ржпрж╝рзЗ ржПржХржЯрж┐ржорж╛рждрзНрж░ ржЖржЙржЯржкрзБржЯ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржПржХрждрзНрж░рж┐ржд ржХрж░рзЗржиред ржПржЯрж┐ `select`-ржПрж░ ржПржХржЯрж┐ ржЦрзБржм рж╕рж╛ржзрж╛рж░ржг ржмрзНржпржмрж╣рж╛рж░ред

ржзрж░рзБржи, ржЖржкржирж╛рж░ ржжрзБржЯрж┐ рж╕рзЛрж░рзНрж╕ (producer) ржЖржЫрзЗ, ржпрж╛рж░рж╛ ржкрзНрж░рждрзНржпрзЗржХрзЗ ржирж┐ржЬрзЗржжрзЗрж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржбрзЗржЯрж╛ ржкрж╛ржарж╛ржЪрзНржЫрзЗред ржЖржкржирж┐ рж╕рзЗржЗ ржжрзБржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓ржХрзЗ "merge" ржХрж░рзЗ ржПржХржЯрж┐ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржЖржирждрзЗ ржЪрж╛ржиред

ржЖржорж░рж╛ ржПржЗ ржХрж╛ржЬржЯрж┐ ржХрж░рж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ ржлрж╛ржВрж╢ржи рждрзИрж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░рж┐ред


### ЁЯТ╗ Exercises

### тЪб Example 1: Two Channels, First Ready Wins

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "ЁЯНО From channel 1"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "ЁЯНМ From channel 2"
    }()

    select {
    case msg1 := <-ch1:
        fmt.Println(msg1)
    case msg2 := <-ch2:
        fmt.Println(msg2)
    }
}
```

<details>
<summary>ЁЯТм ржкрзНрж░рж╢рзНржи рзз: **go routine** ржерж╛ржХрж╛ рж╕рждрзНрждрзНржмрзЗржУ ржЖржорж░рж╛ ржХрзЗржи `WaitGroup` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐ржирж┐?</summary>

**ржЙрждрзНрждрж░:**
ржХрж╛рж░ржг `select` ржирж┐ржЬрзЗржЗ **channel ржерзЗржХрзЗ data ржкрж╛ржУрзЯрж╛рж░ ржЬржирзНржп ржмрзНрж▓ржХ ржХрж░рзЗ ржерж╛ржХрзЗ**ред
ржпрждржХрзНрж╖ржг ржирж╛ ржХрзЛржирзЛ ржЪрзНржпрж╛ржирзЗрж▓ ready рж╣рзЯ, main goroutine ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред
ржЕрж░рзНржерж╛рзО main ржЖржЧрзЗржнрж╛ржЧрзЗ terminate рж╣рзЯ ржирж╛ред

`WaitGroup` ржжрж░ржХрж╛рж░ рж╣рзЯ ржпржЦржи:

* ржХрзЛржирзЛ channel ржирзЗржЗ, рж╢рзБржзрзБ goroutine ржЪрж▓ржЫрзЗ, ржЕржержмрж╛
* рждрзБржорж┐ manualржнрж╛ржмрзЗ goroutine рж╢рзЗрж╖ рж╣ржУрзЯрж╛ ржкрж░рзНржпржирзНржд ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рждрзЗ ржЪрж╛ржУред

ЁЯзй ржЙржжрж╛рж╣рж░ржг:

```go
// select ржирж┐ржЬрзЗржЗ ржмрзНрж▓ржХ ржХрж░ржмрзЗ
select {
case msg := <-ch:
    fmt.Println(msg)
}

// WaitGroup ржжрж░ржХрж╛рж░ ржпржЦржи ржХрзЛржирзЛ channel ржирзЗржЗ
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    fmt.Println("working...")
}()
wg.Wait()
```

тЬЕ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк:
ржпржЦржи `select` ржмрж╛ `<-ch` ржЖржЫрзЗ тЖТ main goroutine ржирж┐ржЬрзЗржЗ wait ржХрж░рзЗ тЖТ `WaitGroup` ржжрж░ржХрж╛рж░ ржирзЗржЗред

</details>

<details>
<summary>ЁЯТм ржкрзНрж░рж╢рзНржи рзи: ржХрзЗржи go routine рж╕рж░рж┐ржпрж╝рзЗ ржжрж┐рж▓рзЗржУ ржХрзЛржбрзЗ тАЬfatal error: all goroutines are asleep - deadlock!тАЭ ржЖрж╕рзЗ?</summary>

**ржЙрждрзНрждрж░:**
ржХрж╛рж░ржг ржХрзЛржирзЛ goroutine ржЪрзНржпрж╛ржирзЗрж▓рзЗ data ржкрж╛ржарж╛ржЪрзНржЫрзЗ ржирж╛, ржЕржержЪ `select` ржЪрзНржпрж╛ржирзЗрж▓ ржерзЗржХрзЗ data **receive ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░ржЫрзЗ**ред

```go
ch1 := make(chan string)
ch2 := make(chan string)

select {
case msg1 := <-ch1:
    fmt.Println(msg1)
case msg2 := <-ch2:
    fmt.Println(msg2)
}
```

ЁЯСЙ ржПржЦрж╛ржирзЗ:

* `ch1` ржУ `ch2` ржерзЗржХрзЗ ржХрзЗржЙ send ржХрж░ржЫрзЗ ржирж╛ред
* `select` ржжрзБржЗржЯрж┐рждрзЗржЗ receive ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗред
* ржлрж▓рзЗ main goroutine ржмрзНрж▓ржХ рж╣рзЯрзЗ ржпрж╛рзЯ ржПржмржВ ржЕржирзНржп ржХрзЛржирзЛ goroutineржУ ржЪрж▓ржЫрзЗ ржирж╛ред

Go runtime ржмрзБржЭрзЗ ржпрж╛рзЯ тАЬрж╕ржмрж╛ржЗ ржШрзБржорж┐рзЯрзЗ ржЖржЫрзЗтАЭ ЁЯШ┤
рждржЦржи panic ржжрзЗрзЯ:

```
fatal error: all goroutines are asleep - deadlock!
```

тЬЕ рж╕ржорж╛ржзрж╛ржи:
ржПржХржЯрж╛ goroutine ржерзЗржХрзЗ data ржкрж╛ржарж╛ржУ ржмрж╛ buffered channel ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛред

```go
go func() { ch1 <- "ЁЯНО From channel 1" }()
go func() { ch2 <- "ЁЯНМ From channel 2" }()
```

ржЕржержмрж╛

```go
ch1 := make(chan string, 1)
ch1 <- "ЁЯНО From buffered channel"
select {
case msg := <-ch1:
    fmt.Println(msg)
}
```

ЁЯза рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк:
**Deadlock рж╣рзЯ ржпржЦржи рж╕ржмрж╛ржЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ ржХрж┐ржирзНрждрзБ ржХрзЗржЙ ржХрж╛ржЬ ржХрж░рзЗ ржирж╛ред**

## ЁЯТб Deadlock Rule рж╕рж╣ржЬржнрж╛ржмрзЗ

| ржЕржмрж╕рзНржерж╛                                                 | ржлрж▓рж╛ржлрж▓             |
| ------------------------------------------------------ | ----------------- |
| Channel ржерзЗржХрзЗ receive рж╣ржЪрзНржЫрзЗ ржХрж┐ржирзНрждрзБ ржХрзЗржЙ send ржХрж░ржЫрзЗ ржирж╛     | Deadlock          |
| Channel-ржП send рж╣ржЪрзНржЫрзЗ ржХрж┐ржирзНрждрзБ ржХрзЗржЙ receive ржХрж░ржЫрзЗ ржирж╛        | Deadlock          |
| Unbuffered channel тЖТ send & receive ржПржХрж╕рж╛ржерзЗ ржирж╛ рж╣рж▓рзЗ      | Deadlock          |
| Buffered channel тЖТ capacity рж╢рзЗрж╖ рж╣рзЯрзЗ ржЧрзЗрж▓рзЗ send ржмрзНрж▓ржХ рж╣ржмрзЗ | Possible Deadlock |

</details>


---

### тЪЩя╕П Example 2: Add Default Case (Non-blocking)

```go
select {
case msg := <-ch1:
    fmt.Println("Received:", msg)
default:
    fmt.Println("No channel ready тАФ moving on ЁЯЪА")
}
```

---

### тП░ Example 3: Add Timeout

```go
select {
case msg := <-ch1:
    fmt.Println("Got:", msg)
case <-time.After(2 * time.Second):
    fmt.Println("Timeout! тП░ No data received.")
}
```

---

## ЁЯзй Bonus: Context Cancellation

ржпржжрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржорзЯ ржкрж░рзЗ рж╕ржм ржмржирзНржз ржХрж░рждрзЗ ржЪрж╛ржУ ЁЯСЗ

```go
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

for {
    select {
    case msg := <-out:
        fmt.Println(msg)
    case <-ctx.Done():
        fmt.Println("ЁЯЫС Stopped by context timeout.")
        return
    }
}
```

---

## ЁЯз╛ **Mini Cheat Sheet тАФ `select` Quick Recall**

| Feature        | Syntax                         | Behavior                    |
| -------------- | ------------------------------ | --------------------------- |
| Basic select   | `select { case msg := <-ch: }` | Waits for any ready channel |
| Default case   | `default:`                     | Prevents blocking           |
| Timeout        | `case <-time.After(d):`        | Triggers after duration     |
| Fan-in         | Combine multiple channels      | Use select inside goroutine |
| Context cancel | `case <-ctx.Done():`           | Stop gracefully             |
| Rule           | тАЬFirst ready winsтАЭ             | Random if multiple ready    |

---

## ЁЯза Summary (ржмрж╛ржВрж▓рж╛рзЯ рж╕рж╛рж░рж╛ржВрж╢)

* `select` ржПржХрж╛ржзрж┐ржХ ржЪрзНржпрж╛ржирзЗрж▓ ржПржХрж╕рж╛ржерзЗ ржоржирж┐ржЯрж░ ржХрж░рзЗред
* ржпрзЗ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЧрзЗ ready рж╣рзЯ, рж╕рзЗржЯрж╛рж░ case ржЪрж╛рж▓рзБ рж╣рзЯред
* `default` case ржжрж┐рж▓рзЗ ржмрзНрж▓ржХ рж╣рзЯ ржирж╛ред
* `time.After` ржжрж┐рзЯрзЗ timeout рж╕рзЗржЯ ржХрж░рж╛ ржпрж╛рзЯред
* **Fan-in pattern** ржжрж┐рзЯрзЗ ржПржХрж╛ржзрж┐ржХ channel merge ржХрж░рж╛ ржпрж╛рзЯред
* `context.WithTimeout` ржжрж┐рзЯрзЗ clean stop ржХрж░рж╛ ржпрж╛рзЯред

-----