# **Golang Maps - MDX Notes**

```mdx
# Maps in Go

Maps are Go's built-in **key-value** data structure, similar to dictionaries in Python or objects in JavaScript.

## **1. Declaration & Initialization**

### **Empty Map**
```go
// Syntax: make(map[keyType]valueType)
m := make(map[string]int)
```

### **Map with Initial Values**
```go
colors := map[string]string{
    "red":   "#FF0000",
    "green": "#00FF00",
    "blue":  "#0000FF",
}
```

---

## **2. Basic Operations**

### **Insert/Update**
```go
m["key"] = 42      // Insert
m["key"] = 100     // Update
```

### **Read**
```go
value := m["key"]   // Returns zero-value if key doesn't exist
```

### **Check Existence**
```go
value, exists := m["key"]
if exists {
    fmt.Println("Key exists:", value)
}
```

### **Delete**
```go
delete(m, "key")   // Removes key-value pair
```

---

## **3. Iterating Over Maps**
```go
for key, value := range m {
    fmt.Printf("Key: %s, Value: %v\n", key, value)
}
```

### **Keys Only**
```go
for key := range m {
    fmt.Println("Key:", key)
}
```

### **Values Only**
```go
for _, value := range m {
    fmt.Println("Value:", value)
}
```

---

## **4. Map Characteristics**
- **Unordered**: Iteration order is random.
- **Dynamic**: Grows automatically.
- **Reference Type**: Passed by reference (modifications affect original).
- **Zero Value**: `nil` (must initialize with `make` before use).

---

## **5. Practical Example: Word Count**
```go
func wordCount(s string) map[string]int {
    words := strings.Fields(s)
    count := make(map[string]int)

    for _, word := range words {
        count[word]++
    }

    return count
}

// Usage
text := "hello world hello"
fmt.Println(wordCount(text)) // Output: map[hello:2 world:1]
```

---

## **6. Common Pitfalls**
1. **Nil Map Panic**
   ```go
   var m map[string]int
   m["key"] = 1 // PANIC: assignment to nil map
   ```
   **Fix:** Use `make` first.

2. **Concurrent Writes**
   - Maps are **not thread-safe** (use `sync.Mutex` or `sync.Map`).

3. **Floating-Point Keys**
   - Avoid `float64` keys due to precision issues.

---

## **7. Advanced: Nested Maps**
```go
users := map[string]map[string]bool{
    "john": {"admin": true, "active": false},
    "jane": {"admin": false, "active": true},
}

if users["john"]["admin"] {
    fmt.Println("John is an admin")
}
```

---

## **Summary Table**
| Operation          | Syntax                     |
|--------------------|----------------------------|
| Create             | `m := make(map[K]V)`       |
| Insert/Update      | `m[key] = value`           |
| Read               | `val := m[key]`            |
| Check Existence    | `val, ok := m[key]`        |
| Delete             | `delete(m, key)`           |
| Iterate            | `for k, v := range m {...}`|

> **ğŸ“Œ Tip:** Use `len(m)` to get the number of key-value pairs.